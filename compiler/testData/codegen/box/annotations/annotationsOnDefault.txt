MODULE <test-module>
  FILE /annotationsOnDefault.kt
    CLASS ANNOTATION_CLASS Ann
      CONSTRUCTOR public constructor Ann(/*0*/ x: kotlin.Int)
        BLOCK_BODY
          DELEGATING_CONSTRUCTOR_CALL Any
          SET_BACKING_FIELD x type=kotlin.Unit operator=null
            receiver: THIS @kotlin.annotation.Retention(value = AnnotationRetention.RUNTIME) public final annotation class Ann : kotlin.Annotation type=Ann
            value: GET_VAR x type=kotlin.Int operator=INITIALIZE_PROPERTY_FROM_PARAMETER
          INSTANCE_INITIALIZER_CALL classDescriptor=Ann
      PROPERTY public final val x: kotlin.Int
        EXPRESSION_BODY
          GET_VAR x type=kotlin.Int operator=INITIALIZE_PROPERTY_FROM_PARAMETER
    CLASS CLASS A
      FUN @Ann(x = 1) public final fun foo(/*0*/ x: kotlin.Int, /*1*/ y: kotlin.Int = ..., /*2*/ z: kotlin.Int): kotlin.Unit
        y: EXPRESSION_BODY
          CONST Int type=kotlin.Int value='2'
        BLOCK_BODY
      CONSTRUCTOR @Ann(x = 1) public constructor A(/*0*/ x: kotlin.Int, /*1*/ y: kotlin.Int = ..., /*2*/ z: kotlin.Int)
        y: EXPRESSION_BODY
          CONST Int type=kotlin.Int value='2'
        BLOCK_BODY
          DELEGATING_CONSTRUCTOR_CALL Any
          INSTANCE_INITIALIZER_CALL classDescriptor=A
    CLASS CLASS B
      CONSTRUCTOR @Ann(x = 1) public constructor B(/*0*/ x: kotlin.Int, /*1*/ y: kotlin.Int = ..., /*2*/ z: kotlin.Int)
        y: EXPRESSION_BODY
          CONST Int type=kotlin.Int value='2'
        BLOCK_BODY
          DELEGATING_CONSTRUCTOR_CALL Any
          INSTANCE_INITIALIZER_CALL classDescriptor=B
    FUN public fun test(/*0*/ name: kotlin.String, /*1*/ annotations: kotlin.Array<out kotlin.Annotation>): kotlin.Unit
      BLOCK_BODY
        CALL .assertEquals type=kotlin.Unit operator=null
          expected: CONST Int type=kotlin.Int value='1'
          actual: CALL .<get-x> type=kotlin.Int operator=GET_PROPERTY
            $this: CALL .single type=Ann operator=null
              $receiver: CALL .filterIsInstance type=kotlin.collections.List<Ann> operator=null
                $receiver: GET_VAR annotations type=kotlin.Array<out kotlin.Annotation> operator=null
          message: STRING_CONCATENATION type=kotlin.String
            GET_VAR name type=kotlin.String operator=null
            CONST String type=kotlin.String value='[0]'
    FUN public fun box(): kotlin.String
      BLOCK_BODY
        VAR val foo: java.lang.reflect.Method!
          CALL .first type=java.lang.reflect.Method! operator=null
            $receiver: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=kotlin.Array<out java.lang.reflect.Method!>
              CALL .getDeclaredMethods type=kotlin.Array<(out) java.lang.reflect.Method!>! operator=null
                $this: CALL .<get-java> type=java.lang.Class<A> operator=GET_PROPERTY
                  $receiver: CLASS_REFERENCE A type=kotlin.reflect.KClass<A>
            predicate: BLOCK type=(java.lang.reflect.Method!) -> kotlin.Boolean operator=LAMBDA
              FUN local final fun <anonymous>(/*0*/ it: java.lang.reflect.Method!): kotlin.Boolean
                BLOCK_BODY
                  RETURN type=kotlin.Nothing from=<anonymous>
                    CALL .EQEQ type=kotlin.Boolean operator=EQEQ
                      arg0: CALL .getName type=kotlin.String! operator=null
                        $this: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=java.lang.reflect.Method
                          GET_VAR it type=java.lang.reflect.Method! operator=null
                      arg1: CONST String type=kotlin.String value='foo'
              CALLABLE_REFERENCE <anonymous> type=(java.lang.reflect.Method!) -> kotlin.Boolean operator=LAMBDA
        CALL .test type=kotlin.Unit operator=null
          name: CONST String type=kotlin.String value='foo'
          annotations: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=kotlin.Array<out kotlin.Annotation!>
            CALL .getDeclaredAnnotations type=kotlin.Array<(out) kotlin.Annotation!>! operator=null
              $this: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=java.lang.reflect.Method
                GET_VAR foo type=java.lang.reflect.Method! operator=null
        VAR val fooDefault: java.lang.reflect.Method!
          CALL .first type=java.lang.reflect.Method! operator=null
            $receiver: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=kotlin.Array<out java.lang.reflect.Method!>
              CALL .getDeclaredMethods type=kotlin.Array<(out) java.lang.reflect.Method!>! operator=null
                $this: CALL .<get-java> type=java.lang.Class<A> operator=GET_PROPERTY
                  $receiver: CLASS_REFERENCE A type=kotlin.reflect.KClass<A>
            predicate: BLOCK type=(java.lang.reflect.Method!) -> kotlin.Boolean operator=LAMBDA
              FUN local final fun <anonymous>(/*0*/ it: java.lang.reflect.Method!): kotlin.Boolean
                BLOCK_BODY
                  RETURN type=kotlin.Nothing from=<anonymous>
                    CALL .EQEQ type=kotlin.Boolean operator=EQEQ
                      arg0: CALL .getName type=kotlin.String! operator=null
                        $this: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=java.lang.reflect.Method
                          GET_VAR it type=java.lang.reflect.Method! operator=null
                      arg1: STRING_CONCATENATION type=kotlin.String
                        CONST String type=kotlin.String value='foo'
                        CONST String type=kotlin.String value='$'
                        CONST String type=kotlin.String value='default'
              CALLABLE_REFERENCE <anonymous> type=(java.lang.reflect.Method!) -> kotlin.Boolean operator=LAMBDA
        CALL .test type=kotlin.Unit operator=null
          name: CONST String type=kotlin.String value='foo'
          annotations: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=kotlin.Array<out kotlin.Annotation!>
            CALL .getDeclaredAnnotations type=kotlin.Array<(out) kotlin.Annotation!>! operator=null
              $this: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=java.lang.reflect.Method
                GET_VAR foo type=java.lang.reflect.Method! operator=null
        BLOCK type=kotlin.Unit operator=DESTRUCTURING_DECLARATION
          VAR val tmp0_container: kotlin.Pair<kotlin.collections.List<java.lang.reflect.Constructor<*>!>, kotlin.collections.List<java.lang.reflect.Constructor<*>!>>
            CALL .partition type=kotlin.Pair<kotlin.collections.List<java.lang.reflect.Constructor<*>!>, kotlin.collections.List<java.lang.reflect.Constructor<*>!>> operator=null
              $receiver: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=kotlin.Array<out java.lang.reflect.Constructor<*>!>
                CALL .getDeclaredConstructors type=kotlin.Array<(out) java.lang.reflect.Constructor<*>!>! operator=null
                  $this: CALL .<get-java> type=java.lang.Class<A> operator=GET_PROPERTY
                    $receiver: CLASS_REFERENCE A type=kotlin.reflect.KClass<A>
              predicate: BLOCK type=(java.lang.reflect.Constructor<*>!) -> kotlin.Boolean operator=LAMBDA
                FUN local final fun <anonymous>(/*0*/ it: java.lang.reflect.Constructor<*>!): kotlin.Boolean
                  BLOCK_BODY
                    RETURN type=kotlin.Nothing from=<anonymous>
                      CALL .EQEQ type=kotlin.Boolean operator=EQEQ
                        arg0: CALL .<get-size> type=kotlin.Int operator=GET_PROPERTY
                          $this: TYPE_OP operator=IMPLICIT_CAST typeOperand=kotlin.Array<java.lang.Class<*>!>
                            TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=kotlin.Array<out java.lang.Class<*>!>
                              CALL .getParameterTypes type=kotlin.Array<(out) java.lang.Class<*>!>! operator=null
                                $this: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=java.lang.reflect.Constructor<*>
                                  GET_VAR it type=java.lang.reflect.Constructor<*>! operator=null
                        arg1: CONST Int type=kotlin.Int value='3'
                CALLABLE_REFERENCE <anonymous> type=(java.lang.reflect.Constructor<*>!) -> kotlin.Boolean operator=LAMBDA
          VAR val secondary: kotlin.collections.List<java.lang.reflect.Constructor<*>!>
            CALL .component1 type=kotlin.collections.List<java.lang.reflect.Constructor<*>!> operator=COMPONENT_N(index=1)
              $this: GET_VAR tmp0_container type=kotlin.Pair<kotlin.collections.List<java.lang.reflect.Constructor<*>!>, kotlin.collections.List<java.lang.reflect.Constructor<*>!>> operator=null
          VAR val secondaryDefault: kotlin.collections.List<java.lang.reflect.Constructor<*>!>
            CALL .component2 type=kotlin.collections.List<java.lang.reflect.Constructor<*>!> operator=COMPONENT_N(index=2)
              $this: GET_VAR tmp0_container type=kotlin.Pair<kotlin.collections.List<java.lang.reflect.Constructor<*>!>, kotlin.collections.List<java.lang.reflect.Constructor<*>!>> operator=null
        CALL .test type=kotlin.Unit operator=null
          name: CONST String type=kotlin.String value='secondary'
          annotations: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=kotlin.Array<out kotlin.Annotation!>
            CALL .getDeclaredAnnotations type=kotlin.Array<(out) kotlin.Annotation!>! operator=null
              $this: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=java.lang.reflect.Constructor<*>
                CALL .get type=java.lang.reflect.Constructor<*>! operator=GET_ARRAY_ELEMENT
                  $this: GET_VAR secondary type=kotlin.collections.List<java.lang.reflect.Constructor<*>!> operator=null
                  index: CONST Int type=kotlin.Int value='0'
        CALL .test type=kotlin.Unit operator=null
          name: STRING_CONCATENATION type=kotlin.String
            CONST String type=kotlin.String value='secondary'
            CONST String type=kotlin.String value='$'
            CONST String type=kotlin.String value='default'
          annotations: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=kotlin.Array<out kotlin.Annotation!>
            CALL .getDeclaredAnnotations type=kotlin.Array<(out) kotlin.Annotation!>! operator=null
              $this: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=java.lang.reflect.Constructor<*>
                CALL .get type=java.lang.reflect.Constructor<*>! operator=GET_ARRAY_ELEMENT
                  $this: GET_VAR secondaryDefault type=kotlin.collections.List<java.lang.reflect.Constructor<*>!> operator=null
                  index: CONST Int type=kotlin.Int value='0'
        BLOCK type=kotlin.Unit operator=DESTRUCTURING_DECLARATION
          VAR val tmp1_container: kotlin.Pair<kotlin.collections.List<java.lang.reflect.Constructor<*>!>, kotlin.collections.List<java.lang.reflect.Constructor<*>!>>
            CALL .partition type=kotlin.Pair<kotlin.collections.List<java.lang.reflect.Constructor<*>!>, kotlin.collections.List<java.lang.reflect.Constructor<*>!>> operator=null
              $receiver: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=kotlin.Array<out java.lang.reflect.Constructor<*>!>
                CALL .getConstructors type=kotlin.Array<(out) java.lang.reflect.Constructor<*>!>! operator=null
                  $this: CALL .<get-java> type=java.lang.Class<B> operator=GET_PROPERTY
                    $receiver: CLASS_REFERENCE B type=kotlin.reflect.KClass<B>
              predicate: BLOCK type=(java.lang.reflect.Constructor<*>!) -> kotlin.Boolean operator=LAMBDA
                FUN local final fun <anonymous>(/*0*/ it: java.lang.reflect.Constructor<*>!): kotlin.Boolean
                  BLOCK_BODY
                    RETURN type=kotlin.Nothing from=<anonymous>
                      CALL .EQEQ type=kotlin.Boolean operator=EQEQ
                        arg0: CALL .<get-size> type=kotlin.Int operator=GET_PROPERTY
                          $this: TYPE_OP operator=IMPLICIT_CAST typeOperand=kotlin.Array<java.lang.Class<*>!>
                            TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=kotlin.Array<out java.lang.Class<*>!>
                              CALL .getParameterTypes type=kotlin.Array<(out) java.lang.Class<*>!>! operator=null
                                $this: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=java.lang.reflect.Constructor<*>
                                  GET_VAR it type=java.lang.reflect.Constructor<*>! operator=null
                        arg1: CONST Int type=kotlin.Int value='3'
                CALLABLE_REFERENCE <anonymous> type=(java.lang.reflect.Constructor<*>!) -> kotlin.Boolean operator=LAMBDA
          VAR val primary: kotlin.collections.List<java.lang.reflect.Constructor<*>!>
            CALL .component1 type=kotlin.collections.List<java.lang.reflect.Constructor<*>!> operator=COMPONENT_N(index=1)
              $this: GET_VAR tmp1_container type=kotlin.Pair<kotlin.collections.List<java.lang.reflect.Constructor<*>!>, kotlin.collections.List<java.lang.reflect.Constructor<*>!>> operator=null
          VAR val primaryDefault: kotlin.collections.List<java.lang.reflect.Constructor<*>!>
            CALL .component2 type=kotlin.collections.List<java.lang.reflect.Constructor<*>!> operator=COMPONENT_N(index=2)
              $this: GET_VAR tmp1_container type=kotlin.Pair<kotlin.collections.List<java.lang.reflect.Constructor<*>!>, kotlin.collections.List<java.lang.reflect.Constructor<*>!>> operator=null
        CALL .test type=kotlin.Unit operator=null
          name: CONST String type=kotlin.String value='primary'
          annotations: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=kotlin.Array<out kotlin.Annotation!>
            CALL .getDeclaredAnnotations type=kotlin.Array<(out) kotlin.Annotation!>! operator=null
              $this: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=java.lang.reflect.Constructor<*>
                CALL .get type=java.lang.reflect.Constructor<*>! operator=GET_ARRAY_ELEMENT
                  $this: GET_VAR primary type=kotlin.collections.List<java.lang.reflect.Constructor<*>!> operator=null
                  index: CONST Int type=kotlin.Int value='0'
        CALL .test type=kotlin.Unit operator=null
          name: STRING_CONCATENATION type=kotlin.String
            CONST String type=kotlin.String value='primary'
            CONST String type=kotlin.String value='$'
            CONST String type=kotlin.String value='default'
          annotations: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=kotlin.Array<out kotlin.Annotation!>
            CALL .getDeclaredAnnotations type=kotlin.Array<(out) kotlin.Annotation!>! operator=null
              $this: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=java.lang.reflect.Constructor<*>
                CALL .get type=java.lang.reflect.Constructor<*>! operator=GET_ARRAY_ELEMENT
                  $this: GET_VAR primaryDefault type=kotlin.collections.List<java.lang.reflect.Constructor<*>!> operator=null
                  index: CONST Int type=kotlin.Int value='0'
        RETURN type=kotlin.Nothing from=box
          CONST String type=kotlin.String value='OK'
