MODULE <test-module>
  FILE /nonLocalReturn.kt
    PROPERTY public val count: kotlin.Int = 10
      EXPRESSION_BODY
        CONST Int type=kotlin.Int value='10'
    PROPERTY public var index: kotlin.Int
      EXPRESSION_BODY
        CONST Int type=kotlin.Int value='0'
    PROPERTY public val doneSignal: java.util.concurrent.CountDownLatch
      EXPRESSION_BODY
        CALL .<init> type=java.util.concurrent.CountDownLatch operator=null
          p0: CALL .<get-count> type=kotlin.Int operator=GET_PROPERTY
    PROPERTY public val startSignal: java.util.concurrent.CountDownLatch
      EXPRESSION_BODY
        CALL .<init> type=java.util.concurrent.CountDownLatch operator=null
          p0: CONST Int type=kotlin.Int value='1'
    PROPERTY public val mutex: kotlin.Any
      EXPRESSION_BODY
        CALL .<init> type=java.lang.Object operator=null
    PROPERTY public val results: java.util.ArrayList<kotlin.Int>
      EXPRESSION_BODY
        CALL .arrayListOf type=java.util.ArrayList<kotlin.Int> operator=null
    PROPERTY public val executorService: java.util.concurrent.ExecutorService!
      EXPRESSION_BODY
        CALL .newFixedThreadPool type=java.util.concurrent.ExecutorService! operator=null
          p0: CALL .<get-count> type=kotlin.Int operator=GET_PROPERTY
    CLASS CLASS MyException
      CONSTRUCTOR public constructor MyException(/*0*/ message: kotlin.String)
        BLOCK_BODY
          DELEGATING_CONSTRUCTOR_CALL Exception
            p0: GET_VAR message type=kotlin.String operator=null
          INSTANCE_INITIALIZER_CALL classDescriptor=MyException
    CLASS ENUM_CLASS ExecutionType
      CONSTRUCTOR private constructor ExecutionType()
        BLOCK_BODY
          ENUM_CONSTRUCTOR_CALL Enum super
          INSTANCE_INITIALIZER_CALL classDescriptor=ExecutionType
      ENUM_ENTRY enum entry LOCAL
        init: ENUM_CONSTRUCTOR_CALL ExecutionType LOCAL
      ENUM_ENTRY enum entry NON_LOCAL_SIMPLE
        init: ENUM_CONSTRUCTOR_CALL ExecutionType NON_LOCAL_SIMPLE
      ENUM_ENTRY enum entry NON_LOCAL_EXCEPTION
        init: ENUM_CONSTRUCTOR_CALL ExecutionType NON_LOCAL_EXCEPTION
      ENUM_ENTRY enum entry NON_LOCAL_FINALLY
        init: ENUM_CONSTRUCTOR_CALL ExecutionType NON_LOCAL_FINALLY
      ENUM_ENTRY enum entry NON_LOCAL_EXCEPTION_AND_FINALLY
        init: ENUM_CONSTRUCTOR_CALL ExecutionType NON_LOCAL_EXCEPTION_AND_FINALLY
      ENUM_ENTRY enum entry NON_LOCAL_EXCEPTION_AND_FINALLY_WITH_RETURN
        init: ENUM_CONSTRUCTOR_CALL ExecutionType NON_LOCAL_EXCEPTION_AND_FINALLY_WITH_RETURN
      ENUM_ENTRY enum entry NON_LOCAL_NESTED
        init: ENUM_CONSTRUCTOR_CALL ExecutionType NON_LOCAL_NESTED
      FUN public final /*synthesized*/ fun values(): kotlin.Array<ExecutionType>
        SYNTHETIC_BODY kind=ENUM_VALUES
      FUN public final /*synthesized*/ fun valueOf(/*0*/ value: kotlin.String): ExecutionType
        SYNTHETIC_BODY kind=ENUM_VALUEOF
    CLASS CLASS TestLocal
      CONSTRUCTOR public constructor TestLocal(/*0*/ name: kotlin.String, /*1*/ executionType: ExecutionType)
        BLOCK_BODY
          DELEGATING_CONSTRUCTOR_CALL Any
          SET_BACKING_FIELD name type=kotlin.Unit operator=null
            receiver: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
            value: GET_VAR name type=kotlin.String operator=INITIALIZE_PROPERTY_FROM_PARAMETER
          SET_BACKING_FIELD executionType type=kotlin.Unit operator=null
            receiver: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
            value: GET_VAR executionType type=ExecutionType operator=INITIALIZE_PROPERTY_FROM_PARAMETER
          INSTANCE_INITIALIZER_CALL classDescriptor=TestLocal
      PROPERTY public final val name: kotlin.String
        EXPRESSION_BODY
          GET_VAR name type=kotlin.String operator=INITIALIZE_PROPERTY_FROM_PARAMETER
      PROPERTY public final val executionType: ExecutionType
        EXPRESSION_BODY
          GET_VAR executionType type=ExecutionType operator=INITIALIZE_PROPERTY_FROM_PARAMETER
      FUN public open override /*1*/ fun call(): kotlin.String
        BLOCK_BODY
          CALL .await type=kotlin.Unit operator=null
            $this: CALL .<get-startSignal> type=java.util.concurrent.CountDownLatch operator=GET_PROPERTY
          RETURN type=kotlin.Nothing from=call
            BLOCK type=kotlin.String operator=WHEN
              VAR val tmp0_subject: ExecutionType
                CALL .<get-executionType> type=ExecutionType operator=GET_PROPERTY
                  $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
              WHEN type=kotlin.String operator=WHEN
                if: CALL .EQEQ type=kotlin.Boolean operator=EQEQ
                  arg0: GET_VAR tmp0_subject type=ExecutionType operator=null
                  arg1: GET_ENUM_VALUE LOCAL type=ExecutionType
                then: CALL .local type=kotlin.String operator=null
                  $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                if: CALL .EQEQ type=kotlin.Boolean operator=EQEQ
                  arg0: GET_VAR tmp0_subject type=ExecutionType operator=null
                  arg1: GET_ENUM_VALUE NON_LOCAL_SIMPLE type=ExecutionType
                then: CALL .nonLocalSimple type=kotlin.String operator=null
                  $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                if: CALL .EQEQ type=kotlin.Boolean operator=EQEQ
                  arg0: GET_VAR tmp0_subject type=ExecutionType operator=null
                  arg1: GET_ENUM_VALUE NON_LOCAL_EXCEPTION type=ExecutionType
                then: CALL .nonLocalWithException type=kotlin.String operator=null
                  $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                if: CALL .EQEQ type=kotlin.Boolean operator=EQEQ
                  arg0: GET_VAR tmp0_subject type=ExecutionType operator=null
                  arg1: GET_ENUM_VALUE NON_LOCAL_FINALLY type=ExecutionType
                then: CALL .nonLocalWithFinally type=kotlin.String operator=null
                  $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                if: CALL .EQEQ type=kotlin.Boolean operator=EQEQ
                  arg0: GET_VAR tmp0_subject type=ExecutionType operator=null
                  arg1: GET_ENUM_VALUE NON_LOCAL_EXCEPTION_AND_FINALLY type=ExecutionType
                then: CALL .nonLocalWithExceptionAndFinally type=kotlin.String operator=null
                  $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                if: CALL .EQEQ type=kotlin.Boolean operator=EQEQ
                  arg0: GET_VAR tmp0_subject type=ExecutionType operator=null
                  arg1: GET_ENUM_VALUE NON_LOCAL_EXCEPTION_AND_FINALLY_WITH_RETURN type=ExecutionType
                then: CALL .nonLocalWithExceptionAndFinallyWithReturn type=kotlin.String operator=null
                  $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                if: CALL .EQEQ type=kotlin.Boolean operator=EQEQ
                  arg0: GET_VAR tmp0_subject type=ExecutionType operator=null
                  arg1: GET_ENUM_VALUE NON_LOCAL_NESTED type=ExecutionType
                then: CALL .nonLocalNested type=kotlin.String operator=null
                  $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                else: CONST String type=kotlin.String value='fail'
      FUN private final fun underMutexFun(): kotlin.Unit
        BLOCK_BODY
          CALL .add type=kotlin.Boolean operator=null
            $this: CALL .<get-results> type=java.util.ArrayList<kotlin.Int> operator=GET_PROPERTY
            element: BLOCK type=kotlin.Int operator=PREFIX_INCR
              BLOCK type=kotlin.Int operator=PREFIX_INCR
                VAR val tmp0: kotlin.Int
                  CALL .inc type=kotlin.Int operator=PREFIX_INCR
                    $this: CALL .<get-index> type=kotlin.Int operator=PREFIX_INCR
                CALL .<set-index> type=kotlin.Unit operator=PREFIX_INCR
                  <set-?>: GET_VAR tmp0 type=kotlin.Int operator=null
                GET_VAR tmp0 type=kotlin.Int operator=null
          CALL .countDown type=kotlin.Unit operator=null
            $this: CALL .<get-doneSignal> type=java.util.concurrent.CountDownLatch operator=GET_PROPERTY
      FUN public final fun local(): kotlin.String
        BLOCK_BODY
          CALL .synchronized type=kotlin.Unit operator=null
            lock: CALL .<get-mutex> type=kotlin.Any operator=GET_PROPERTY
            block: BLOCK type=() -> kotlin.Unit operator=LAMBDA
              FUN local final fun <anonymous>(): kotlin.Unit
                BLOCK_BODY
                  RETURN type=kotlin.Nothing from=<anonymous>
                    CALL .underMutexFun type=kotlin.Unit operator=null
                      $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
              CALLABLE_REFERENCE <anonymous> type=() -> kotlin.Unit operator=LAMBDA
          RETURN type=kotlin.Nothing from=local
            CALL .toString type=kotlin.String operator=null
              $this: CALL .<get-executionType> type=ExecutionType operator=GET_PROPERTY
                $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
      FUN public final fun nonLocalSimple(): kotlin.String
        BLOCK_BODY
          CALL .synchronized type=kotlin.Nothing operator=null
            lock: CALL .<get-mutex> type=kotlin.Any operator=GET_PROPERTY
            block: BLOCK type=() -> kotlin.Nothing operator=LAMBDA
              FUN local final fun <anonymous>(): kotlin.Nothing
                BLOCK_BODY
                  CALL .underMutexFun type=kotlin.Unit operator=null
                    $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                  RETURN type=kotlin.Nothing from=nonLocalSimple
                    CALL .<get-name> type=kotlin.String operator=GET_PROPERTY
                      $this: CALL .<get-executionType> type=ExecutionType operator=GET_PROPERTY
                        $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
              CALLABLE_REFERENCE <anonymous> type=() -> kotlin.Nothing operator=LAMBDA
          RETURN type=kotlin.Nothing from=nonLocalSimple
            CONST String type=kotlin.String value='fail'
      FUN public final fun nonLocalWithException(): kotlin.String
        BLOCK_BODY
          CALL .synchronized type=kotlin.Nothing operator=null
            lock: CALL .<get-mutex> type=kotlin.Any operator=GET_PROPERTY
            block: BLOCK type=() -> kotlin.Nothing operator=LAMBDA
              FUN local final fun <anonymous>(): kotlin.Nothing
                BLOCK_BODY
                  TRY_CATCH type=kotlin.Nothing
                    try: BLOCK type=kotlin.Nothing operator=null
                      CALL .underMutexFun type=kotlin.Unit operator=null
                        $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                      THROW type=kotlin.Nothing
                        CALL .<init> type=MyException operator=null
                          message: CALL .<get-name> type=kotlin.String operator=GET_PROPERTY
                            $this: CALL .<get-executionType> type=ExecutionType operator=GET_PROPERTY
                              $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                    catch e: BLOCK type=kotlin.Nothing operator=null
                      RETURN type=kotlin.Nothing from=nonLocalWithException
                        BLOCK type=kotlin.String operator=EXCLEXCL
                          VAR val tmp0_notnull: kotlin.String?
                            CALL .<get-message> type=kotlin.String? operator=GET_PROPERTY
                              $this: GET_VAR e type=MyException operator=null
                          WHEN type=kotlin.String operator=null
                            if: CALL .EQEQ type=kotlin.Boolean operator=EQEQ
                              arg0: GET_VAR tmp0_notnull type=kotlin.String? operator=null
                              arg1: CONST Null type=kotlin.Nothing? value='null'
                            then: CALL .THROW_NPE type=kotlin.Nothing operator=EXCLEXCL
                            else: GET_VAR tmp0_notnull type=kotlin.String? operator=null
              CALLABLE_REFERENCE <anonymous> type=() -> kotlin.Nothing operator=LAMBDA
          RETURN type=kotlin.Nothing from=nonLocalWithException
            CONST String type=kotlin.String value='fail'
      FUN public final fun nonLocalWithFinally(): kotlin.String
        BLOCK_BODY
          CALL .synchronized type=kotlin.Nothing operator=null
            lock: CALL .<get-mutex> type=kotlin.Any operator=GET_PROPERTY
            block: BLOCK type=() -> kotlin.Nothing operator=LAMBDA
              FUN local final fun <anonymous>(): kotlin.Nothing
                BLOCK_BODY
                  TRY_CATCH type=kotlin.Nothing
                    try: BLOCK type=kotlin.Nothing operator=null
                      CALL .underMutexFun type=kotlin.Unit operator=null
                        $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                      RETURN type=kotlin.Nothing from=nonLocalWithFinally
                        CONST String type=kotlin.String value='fail'
                    finally: BLOCK type=kotlin.Nothing operator=null
                      RETURN type=kotlin.Nothing from=nonLocalWithFinally
                        CALL .<get-name> type=kotlin.String operator=GET_PROPERTY
                          $this: CALL .<get-executionType> type=ExecutionType operator=GET_PROPERTY
                            $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
              CALLABLE_REFERENCE <anonymous> type=() -> kotlin.Nothing operator=LAMBDA
          RETURN type=kotlin.Nothing from=nonLocalWithFinally
            CONST String type=kotlin.String value='fail'
      FUN public final fun nonLocalWithExceptionAndFinally(): kotlin.String
        BLOCK_BODY
          CALL .synchronized type=kotlin.Nothing operator=null
            lock: CALL .<get-mutex> type=kotlin.Any operator=GET_PROPERTY
            block: BLOCK type=() -> kotlin.Nothing operator=LAMBDA
              FUN local final fun <anonymous>(): kotlin.Nothing
                BLOCK_BODY
                  TRY_CATCH type=kotlin.Nothing
                    try: BLOCK type=kotlin.Nothing operator=null
                      CALL .underMutexFun type=kotlin.Unit operator=null
                        $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                      THROW type=kotlin.Nothing
                        CALL .<init> type=MyException operator=null
                          message: CALL .<get-name> type=kotlin.String operator=GET_PROPERTY
                            $this: CALL .<get-executionType> type=ExecutionType operator=GET_PROPERTY
                              $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                    catch e: BLOCK type=kotlin.Nothing operator=null
                      RETURN type=kotlin.Nothing from=nonLocalWithExceptionAndFinally
                        BLOCK type=kotlin.String operator=EXCLEXCL
                          VAR val tmp0_notnull: kotlin.String?
                            CALL .<get-message> type=kotlin.String? operator=GET_PROPERTY
                              $this: GET_VAR e type=MyException operator=null
                          WHEN type=kotlin.String operator=null
                            if: CALL .EQEQ type=kotlin.Boolean operator=EQEQ
                              arg0: GET_VAR tmp0_notnull type=kotlin.String? operator=null
                              arg1: CONST Null type=kotlin.Nothing? value='null'
                            then: CALL .THROW_NPE type=kotlin.Nothing operator=EXCLEXCL
                            else: GET_VAR tmp0_notnull type=kotlin.String? operator=null
                    finally: BLOCK type=kotlin.String operator=null
                      CONST String type=kotlin.String value='123'
              CALLABLE_REFERENCE <anonymous> type=() -> kotlin.Nothing operator=LAMBDA
          RETURN type=kotlin.Nothing from=nonLocalWithExceptionAndFinally
            CONST String type=kotlin.String value='fail'
      FUN public final fun nonLocalWithExceptionAndFinallyWithReturn(): kotlin.String
        BLOCK_BODY
          CALL .synchronized type=kotlin.Nothing operator=null
            lock: CALL .<get-mutex> type=kotlin.Any operator=GET_PROPERTY
            block: BLOCK type=() -> kotlin.Nothing operator=LAMBDA
              FUN local final fun <anonymous>(): kotlin.Nothing
                BLOCK_BODY
                  TRY_CATCH type=kotlin.Nothing
                    try: BLOCK type=kotlin.Nothing operator=null
                      CALL .underMutexFun type=kotlin.Unit operator=null
                        $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                      THROW type=kotlin.Nothing
                        CALL .<init> type=MyException operator=null
                          message: CALL .<get-name> type=kotlin.String operator=GET_PROPERTY
                            $this: CALL .<get-executionType> type=ExecutionType operator=GET_PROPERTY
                              $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                    catch e: BLOCK type=kotlin.Nothing operator=null
                      RETURN type=kotlin.Nothing from=nonLocalWithExceptionAndFinallyWithReturn
                        CONST String type=kotlin.String value='fail1'
                    finally: BLOCK type=kotlin.Nothing operator=null
                      RETURN type=kotlin.Nothing from=nonLocalWithExceptionAndFinallyWithReturn
                        CALL .<get-name> type=kotlin.String operator=GET_PROPERTY
                          $this: CALL .<get-executionType> type=ExecutionType operator=GET_PROPERTY
                            $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
              CALLABLE_REFERENCE <anonymous> type=() -> kotlin.Nothing operator=LAMBDA
          RETURN type=kotlin.Nothing from=nonLocalWithExceptionAndFinallyWithReturn
            CONST String type=kotlin.String value='fail'
      FUN public final fun nonLocalNested(): kotlin.String
        BLOCK_BODY
          CALL .synchronized type=kotlin.Nothing operator=null
            lock: CALL .<get-mutex> type=kotlin.Any operator=GET_PROPERTY
            block: BLOCK type=() -> kotlin.Nothing operator=LAMBDA
              FUN local final fun <anonymous>(): kotlin.Nothing
                BLOCK_BODY
                  TRY_CATCH type=kotlin.Nothing
                    try: BLOCK type=kotlin.Nothing operator=null
                      TRY_CATCH type=kotlin.Nothing
                        try: BLOCK type=kotlin.Nothing operator=null
                          CALL .underMutexFun type=kotlin.Unit operator=null
                            $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                          THROW type=kotlin.Nothing
                            CALL .<init> type=MyException operator=null
                              message: CALL .<get-name> type=kotlin.String operator=GET_PROPERTY
                                $this: CALL .<get-executionType> type=ExecutionType operator=GET_PROPERTY
                                  $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                        catch e: BLOCK type=kotlin.Nothing operator=null
                          RETURN type=kotlin.Nothing from=nonLocalNested
                            CONST String type=kotlin.String value='fail1'
                        finally: BLOCK type=kotlin.Nothing operator=null
                          RETURN type=kotlin.Nothing from=nonLocalNested
                            CALL .<get-name> type=kotlin.String operator=GET_PROPERTY
                              $this: CALL .<get-executionType> type=ExecutionType operator=GET_PROPERTY
                                $this: THIS public final class TestLocal : java.util.concurrent.Callable<kotlin.String> type=TestLocal
                    finally: BLOCK type=kotlin.Unit operator=null
                      VAR val p: kotlin.Int = 2
                        CALL .plus type=kotlin.Int operator=PLUS
                          $this: CONST Int type=kotlin.Int value='1'
                          other: CONST Int type=kotlin.Int value='1'
              CALLABLE_REFERENCE <anonymous> type=() -> kotlin.Nothing operator=LAMBDA
          RETURN type=kotlin.Nothing from=nonLocalNested
            CONST String type=kotlin.String value='fail'
    FUN public fun testTemplate(/*0*/ type: ExecutionType, /*1*/ producer: (kotlin.Int) -> java.util.concurrent.Callable<kotlin.String>): kotlin.String
      BLOCK_BODY
        TRY_CATCH type=kotlin.Unit
          try: BLOCK type=kotlin.Unit operator=null
            VAR val futures: java.util.ArrayList<java.util.concurrent.Future<kotlin.String>>
              CALL .arrayListOf type=java.util.ArrayList<java.util.concurrent.Future<kotlin.String>> operator=null
            BLOCK type=kotlin.Unit operator=FOR_LOOP
              VAR val tmp0_iterator: kotlin.collections.IntIterator
                CALL .iterator type=kotlin.collections.IntIterator operator=FOR_LOOP_ITERATOR
                  $this: CALL .rangeTo type=kotlin.ranges.IntRange operator=RANGE
                    $this: CONST Int type=kotlin.Int value='1'
                    other: CALL .<get-count> type=kotlin.Int operator=GET_PROPERTY
              WHILE label=null operator=FOR_LOOP_INNER_WHILE
                condition: CALL .hasNext type=kotlin.Boolean operator=FOR_LOOP_HAS_NEXT
                  $this: GET_VAR tmp0_iterator type=kotlin.collections.IntIterator operator=null
                body: BLOCK type=kotlin.Unit operator=FOR_LOOP_INNER_WHILE
                  VAR val i: kotlin.Int
                    CALL .next type=kotlin.Int operator=FOR_LOOP_NEXT
                      $this: GET_VAR tmp0_iterator type=kotlin.collections.IntIterator operator=null
                  BLOCK type=kotlin.Boolean operator=null
                    CALL .add type=kotlin.Boolean operator=null
                      $this: GET_VAR futures type=java.util.ArrayList<java.util.concurrent.Future<kotlin.String>> operator=null
                      element: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=java.util.concurrent.Future<kotlin.String!>
                        CALL .submit type=java.util.concurrent.Future<kotlin.String!>! operator=null
                          $this: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=java.util.concurrent.ExecutorService
                            CALL .<get-executorService> type=java.util.concurrent.ExecutorService! operator=GET_PROPERTY
                          p0: CALL .invoke type=java.util.concurrent.Callable<kotlin.String> operator=INVOKE
                            $this: GET_VAR producer type=(kotlin.Int) -> java.util.concurrent.Callable<kotlin.String> operator=VARIABLE_AS_FUNCTION
                            p1: GET_VAR i type=kotlin.Int operator=null
            CALL .countDown type=kotlin.Unit operator=null
              $this: CALL .<get-startSignal> type=java.util.concurrent.CountDownLatch operator=GET_PROPERTY
            VAR val b: kotlin.Boolean
              CALL .await type=kotlin.Boolean operator=null
                $this: CALL .<get-doneSignal> type=java.util.concurrent.CountDownLatch operator=GET_PROPERTY
                p0: CONST Long type=kotlin.Long value='10'
                p1: GET_ENUM_VALUE SECONDS type=java.util.concurrent.TimeUnit
            WHEN type=kotlin.Unit operator=IF
              if: CALL .not type=kotlin.Boolean operator=EXCL
                $this: GET_VAR b type=kotlin.Boolean operator=null
              then: RETURN type=kotlin.Nothing from=testTemplate
                CONST String type=kotlin.String value='fail: processes not finished'
            BLOCK type=kotlin.Unit operator=FOR_LOOP
              VAR val tmp1_iterator: kotlin.collections.IntIterator
                CALL .iterator type=kotlin.collections.IntIterator operator=FOR_LOOP_ITERATOR
                  $this: CALL .rangeTo type=kotlin.ranges.IntRange operator=RANGE
                    $this: CONST Int type=kotlin.Int value='1'
                    other: CALL .<get-count> type=kotlin.Int operator=GET_PROPERTY
              WHILE label=null operator=FOR_LOOP_INNER_WHILE
                condition: CALL .hasNext type=kotlin.Boolean operator=FOR_LOOP_HAS_NEXT
                  $this: GET_VAR tmp1_iterator type=kotlin.collections.IntIterator operator=null
                body: BLOCK type=kotlin.Unit operator=FOR_LOOP_INNER_WHILE
                  VAR val i: kotlin.Int
                    CALL .next type=kotlin.Int operator=FOR_LOOP_NEXT
                      $this: GET_VAR tmp1_iterator type=kotlin.collections.IntIterator operator=null
                  BLOCK type=kotlin.Unit operator=null
                    WHEN type=kotlin.Unit operator=IF
                      if: CALL .NOT type=kotlin.Boolean operator=EXCLEQ
                        arg0: CALL .EQEQ type=kotlin.Boolean operator=EXCLEQ
                          arg0: CALL .get type=kotlin.Int operator=GET_ARRAY_ELEMENT
                            $this: CALL .<get-results> type=java.util.ArrayList<kotlin.Int> operator=GET_PROPERTY
                            index: CALL .minus type=kotlin.Int operator=MINUS
                              $this: GET_VAR i type=kotlin.Int operator=null
                              other: CONST Int type=kotlin.Int value='1'
                          arg1: GET_VAR i type=kotlin.Int operator=null
                      then: RETURN type=kotlin.Nothing from=testTemplate
                        CALL .plus type=kotlin.String operator=PLUS
                          $this: STRING_CONCATENATION type=kotlin.String
                            CONST String type=kotlin.String value='fail '
                            GET_VAR i type=kotlin.Int operator=null
                            CONST String type=kotlin.String value=' != '
                            CALL .get type=kotlin.Int operator=GET_ARRAY_ELEMENT
                              $this: CALL .<get-results> type=java.util.ArrayList<kotlin.Int> operator=GET_PROPERTY
                              index: GET_VAR i type=kotlin.Int operator=null
                            CONST String type=kotlin.String value=': synchronization not works : '
                          other: CALL .joinToString type=kotlin.String operator=null
                            $receiver: CALL .<get-results> type=java.util.ArrayList<kotlin.Int> operator=GET_PROPERTY
            BLOCK type=kotlin.Unit operator=FOR_LOOP
              VAR val tmp2_iterator: kotlin.collections.MutableIterator<java.util.concurrent.Future<kotlin.String>>
                CALL .iterator type=kotlin.collections.MutableIterator<java.util.concurrent.Future<kotlin.String>> operator=FOR_LOOP_ITERATOR
                  $this: GET_VAR futures type=java.util.ArrayList<java.util.concurrent.Future<kotlin.String>> operator=null
              WHILE label=null operator=FOR_LOOP_INNER_WHILE
                condition: CALL .hasNext type=kotlin.Boolean operator=FOR_LOOP_HAS_NEXT
                  $this: GET_VAR tmp2_iterator type=kotlin.collections.MutableIterator<java.util.concurrent.Future<kotlin.String>> operator=null
                body: BLOCK type=kotlin.Unit operator=FOR_LOOP_INNER_WHILE
                  VAR val f: java.util.concurrent.Future<kotlin.String>
                    CALL .next type=java.util.concurrent.Future<kotlin.String> operator=FOR_LOOP_NEXT
                      $this: GET_VAR tmp2_iterator type=kotlin.collections.MutableIterator<java.util.concurrent.Future<kotlin.String>> operator=null
                  BLOCK type=kotlin.Unit operator=null
                    WHEN type=kotlin.Unit operator=IF
                      if: CALL .NOT type=kotlin.Boolean operator=EXCLEQ
                        arg0: CALL .EQEQ type=kotlin.Boolean operator=EXCLEQ
                          arg0: CALL .get type=kotlin.String! operator=null
                            $this: GET_VAR f type=java.util.concurrent.Future<kotlin.String> operator=null
                          arg1: CALL .<get-name> type=kotlin.String operator=GET_PROPERTY
                            $this: GET_VAR type type=ExecutionType operator=null
                      then: RETURN type=kotlin.Nothing from=testTemplate
                        STRING_CONCATENATION type=kotlin.String
                          CONST String type=kotlin.String value='failed result '
                          CALL .get type=kotlin.String! operator=null
                            $this: GET_VAR f type=java.util.concurrent.Future<kotlin.String> operator=null
                          CONST String type=kotlin.String value=' != '
                          CALL .<get-name> type=kotlin.String operator=GET_PROPERTY
                            $this: GET_VAR type type=ExecutionType operator=null
          finally: BLOCK type=kotlin.Unit operator=null
        RETURN type=kotlin.Nothing from=testTemplate
          CONST String type=kotlin.String value='OK'
    FUN public fun runTest(/*0*/ type: ExecutionType): kotlin.String
      BLOCK_BODY
        RETURN type=kotlin.Nothing from=runTest
          CALL .testTemplate type=kotlin.String operator=null
            type: GET_VAR type type=ExecutionType operator=null
            producer: BLOCK type=(kotlin.Int) -> TestLocal operator=LAMBDA
              FUN local final fun <anonymous>(/*0*/ it: kotlin.Int): TestLocal
                BLOCK_BODY
                  RETURN type=kotlin.Nothing from=<anonymous>
                    CALL .<init> type=TestLocal operator=null
                      name: CALL .toString type=kotlin.String operator=null
                        $this: GET_VAR it type=kotlin.Int operator=null
                      executionType: GET_VAR type type=ExecutionType operator=null
              CALLABLE_REFERENCE <anonymous> type=(kotlin.Int) -> TestLocal operator=LAMBDA
    FUN public fun box(): kotlin.String
      BLOCK_BODY
        TRY_CATCH type=kotlin.Unit
          try: BLOCK type=kotlin.Unit operator=null
            BLOCK type=kotlin.Unit operator=FOR_LOOP
              VAR val tmp0_iterator: kotlin.collections.Iterator<ExecutionType>
                CALL .iterator type=kotlin.collections.Iterator<ExecutionType> operator=FOR_LOOP_ITERATOR
                  $this: CALL .values type=kotlin.Array<ExecutionType> operator=null
              WHILE label=null operator=FOR_LOOP_INNER_WHILE
                condition: CALL .hasNext type=kotlin.Boolean operator=FOR_LOOP_HAS_NEXT
                  $this: GET_VAR tmp0_iterator type=kotlin.collections.Iterator<ExecutionType> operator=null
                body: BLOCK type=kotlin.Unit operator=FOR_LOOP_INNER_WHILE
                  VAR val type: ExecutionType
                    CALL .next type=ExecutionType operator=FOR_LOOP_NEXT
                      $this: GET_VAR tmp0_iterator type=kotlin.collections.Iterator<ExecutionType> operator=null
                  BLOCK type=kotlin.Unit operator=null
                    VAR val result: kotlin.String
                      CALL .runTest type=kotlin.String operator=null
                        type: GET_VAR type type=ExecutionType operator=null
                    WHEN type=kotlin.Unit operator=IF
                      if: CALL .NOT type=kotlin.Boolean operator=EXCLEQ
                        arg0: CALL .EQEQ type=kotlin.Boolean operator=EXCLEQ
                          arg0: GET_VAR result type=kotlin.String operator=null
                          arg1: CONST String type=kotlin.String value='OK'
                      then: RETURN type=kotlin.Nothing from=box
                        STRING_CONCATENATION type=kotlin.String
                          CONST String type=kotlin.String value='fail on '
                          GET_VAR type type=ExecutionType operator=null
                          CONST String type=kotlin.String value=' execution: '
                          GET_VAR result type=kotlin.String operator=null
          finally: BLOCK type=kotlin.Unit operator=null
            CALL .shutdown type=kotlin.Unit operator=null
              $this: TYPE_OP operator=IMPLICIT_NOTNULL typeOperand=java.util.concurrent.ExecutorService
                CALL .<get-executorService> type=java.util.concurrent.ExecutorService! operator=GET_PROPERTY
        RETURN type=kotlin.Nothing from=box
          CONST String type=kotlin.String value='OK'
